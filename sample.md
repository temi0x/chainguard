### **Service Endpoint**

The multi-agent system will use a single HTTP POST endpoint

*   **Deployment on:** Google Cloud Run
*   **Method:** `POST`
*   **Endpoint URL (Sample):** `https://chainguard-ai-service-xxxxxx-uc.a.run.app/assess`
    *(Note: this is a dummy url)*
*   **Authentication:** Requests must include an API Key in the `Authorization` header.
    *   **Header:** `Authorization: Bearer <YOUR_API_KEY>`

---

### **API Request Payload**

To initiate a risk assessment, send a JSON object in the request body with the protocol's unique identifier.
Since we have this in the JSON file Collins created

**Content-Type:** `application/json`

#### **Request Body Structure**

| Field | Type | Required | Description |
| :--- | :--- | :--- | :--- |
| `protocol_name` | string | Yes | The unique identifier for the DeFi protocol (e.g., "aave-v3", "uniswap-v3", "compound-v2"). |

#### **Example Request**

```json
{
  "protocol_name": "aave-v3"
}
```

---

### **API Response Payload**

Detailed JSON response object containing the complete risk assessment. Can be used for both the frontend and the chainlink function on-chain integrations.

#### **Successful Response (200 OK)**

This is a sample structure returned when an assessment is completed successfully.

**Example Response for a request of `{"protocol_name": "aave-v3"}`:**

```json
{
  "protocol_name": "aave-v3",
  "assessment_timestamp": "2023-10-27T10:30:00Z",
  "risk_score": {
    "overall": 28.5,
    "category": "LOW_RISK",
    "confidence": 0.92,
    "components": {
      "protocol_security": 15,
      "financial_health": 25,
      "governance_quality": 40,
      "data_quality": 95
    }
  },
  "explanation": "Aave v3 is considered a low-risk protocol. It demonstrates strong security practices with multiple audits and a robust bug bounty program. Its financial health is excellent, supported by high TVL and consistent revenue generation. While governance is highly active, some centralization exists in multisig control, representing a minor risk factor. Data sources for this analysis were highly reliable.",
  "key_findings": [
    "Security: Multiple audits from top-tier firms (Trail of Bits, OpenZeppelin).",
    "Centralization: 4/7 multisig for critical admin functions.",
    "Data: Repository migration from aave/aave-protocol to aave-dao/aave-v3-origin was successfully detected and validated.",
    "Sustainability: Protocol revenue consistently exceeds token incentives."
  ],
  "agent_contributions": {
    "data_hunter": { "status": "SUCCESS", "reliability_score": 98.5 },
    "protocol_analyst": { "status": "SUCCESS", "security_score": 90 },
    "market_intelligence": { "status": "SUCCESS", "financial_score": 85 }
  }
}
```

#### **Response Field Descriptions**

| Field | Type | Description |
| :--- | :--- | :--- |
| `protocol_name` | string | Echos the requested protocol identifier. |
| `assessment_timestamp` | string | ISO 8601 timestamp of when the assessment was generated. |
| `risk_score` | object | The core numerical scoring object. |
| `risk_score.overall` | float | The final, weighted risk score (0-100, lower is better). |
| `risk_score.category` | string | Human-readable risk category (`LOW_RISK`, `MEDIUM_RISK`, `HIGH_RISK`). |
| `risk_score.confidence` | float | The system's confidence in the assessment (0.0 - 1.0). |
| `risk_score.components` | object | Breakdown of sub-scores from different risk vectors. |
| `explanation` | string | A natural language summary generated by the Risk Synthesizer Agent. |
| `key_findings` | array(string) | A list of the most critical insights discovered by the agents. |
| `agent_contributions` | object | (For debugging/transparency) A summary of each agent's individual contribution. |

---

### **(EXTRA) Integration Sample for Chainlink Functions**

This is a sample `source.js` file that can be used in a Chainlink Function to call our service and return the overall risk score on-chain.

**`source.js`**
```javascript
// This script requests a risk assessment from the ChainGuard AI API
// and returns the overall risk score to the smart contract.

// Arguments are passed from the smart contract calling the function
const protocolName = args[0];
const apiKey = secrets.chainguardApiKey;

if (!apiKey) {
  throw Error("ChainGuard API Key is not set in secrets.");
}

if (!protocolName) {
  throw Error("Protocol name not provided as an argument.");
}

// 1. CONSTRUCT THE HTTP REQUEST
const chainguardApiRequest = Functions.makeHttpRequest({
  url: `https://chainguard-ai-service-xxxxxx-uc.a.run.app/assess`, // <-- Final production URL goes here
  method: "POST",
  headers: {
    "Content-Type": "application/json",
    "Authorization": `Bearer ${apiKey}`,
  },
  data: {
    "protocol_name": protocolName,
  },
  timeout: 30000, // 30s timeout
});

// 2. EXECUTE THE REQUEST
const [response] = await Promise.all([chainguardApiRequest]);

if (response.error || response.status !== 200) {
  throw Error(response.message || `API request failed with status ${response.status}`);
}

// 3. EXTRACT AND RETURN THE DATA
const responseData = response.data;
const overallScore = responseData.risk_score.overall;

// The score is a float (e.g., 28.5). We multiply by 100 to preserve precision
// before converting to a uint256 for Solidity (e.g., 2850).
const scoreAsInteger = Math.round(overallScore * 100);

console.log(`Risk score for ${protocolName}: ${overallScore}. Returning ${scoreAsInteger} to contract.`);

// Return the result to the smart contract, encoded as a uint256.
return Functions.encodeUint256(scoreAsInteger);
```

**Next Steps (chainlink)**
1.  Store the API key as a Chainlink Functions secret named `chainguardApiKey`.
2.  Your `fulfillRequest` function in the Solidity contract will receive this `uint256` value.
3.  To get the original score in the contract, you will need to divide the received value by 100.
